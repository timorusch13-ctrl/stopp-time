<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stopp-Spiel Final</title>
    <style>
        /* --- CSS-Code beginnt hier --- */
        :root {
            --primary-color: #00ff99; /* Standard-Akzentfarbe (Gr√ºn) */
            --bg-color: #121212;
            --card-bg: #1e1e1e;
            --text-color: #e0e0e0;
            --stop-color: #ff4d4d;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
        }

        .game-container {
            position: relative;
            text-align: center;
            padding: 30px;
            border-radius: 20px;
            background-color: var(--card-bg);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            width: 90%;
            max-width: 450px;
            /* Flexbox f√ºr Layout-Stabilit√§t */
            display: flex; 
            flex-direction: column;
            gap: 20px; /* F√ºgt Abstand zwischen Elementen hinzu */
        }

        /* Obere Icon-Buttons Container */
        .icon-buttons {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            gap: 10px;
        }
        #helpButton {
            position: absolute;
            top: 15px;
            left: 15px;
        }
        .icon-buttons button, #helpButton {
            background: none; border: none; color: var(--text-color);
            font-size: 1.5em; cursor: pointer; opacity: 0.7;
        }
        .icon-buttons button:hover, #helpButton:hover { opacity: 1; }

        h1 { margin-top: 0; color: var(--primary-color); }

        #display {
            height: 100px; 
            margin: 0px auto; /* Margin angepasst, da Container jetzt gap hat */
            border: 5px solid var(--primary-color); 
            border-radius: 50px; 
            display: flex; 
            justify-content: center;
            align-items: center; 
            font-weight: bold;
            color: var(--primary-color);
            font-size: 3.5em; 
            text-align: center; 
            white-space: nowrap; 
            padding: 0 15px; 
            box-sizing: border-box;
            overflow: hidden; 
            transition: width 0.4s ease, font-size 0.3s ease; 
        }

        .precision-1 { width: 150px; font-size: 3.5em; } 
        .precision-2 { width: 180px; font-size: 3.5em; } 
        .precision-3 { width: 220px; font-size: 3.5em; } 
        .precision-4 { width: 280px; font-size: 2.1em; } 
        .precision-5 { width: 340px; font-size: 1.7em; } 


        /* Container f√ºr Button/Slider, um Layout-Spr√ºnge zu verhindern */
        .action-area-container {
            position: relative;
            height: 50px; /* Feste H√∂he, damit nichts springt */
            width: 100%;
        }

        #actionButton, .slider-container {
             /* Nehmen die volle Breite des action-area-container ein */
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
            box-sizing: border-box;
        }

        #actionButton {
            padding: 15px 30px; font-size: 1.2em; cursor: pointer;
            background-color: var(--primary-color); border: none;
            border-radius: 50px; color: var(--card-bg); 
            transition: opacity 0.3s, visibility 0.3s;
            z-index: 2; /* √úber Slider */
        }
        
        #actionButton.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none; 
        }

        #message { font-size: 1em; color: var(--stop-color); min-height: 1.2em; margin: 0;}

        .slider-container {
            display: block; /* Immer block, nur sichtbar/unsichtbar per Klasse */
            background-color: #444; border-radius: 50px;
            overflow: hidden; height: 50px;
            cursor: grab; user-select: none;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
            z-index: 1;
        }
        .slider-container.visible {
            opacity: 1;
            visibility: visible; 
        }
        
        .slider-label {
            position: absolute; top: 0; left: 0; right: 0; text-align: center;
            line-height: 50px; color: #ccc; pointer-events: none; font-size: 0.9em;
            z-index: 0; 
        }
        .slider-button {
            width: 50px; height: 50px; background-color: var(--primary-color); 
            border-radius: 50%; position: absolute; top: 0; 
            display: flex;
            align-items: center; justify-content: center; color: var(--card-bg);
            font-weight: 900; font-size: 1.5em; 
            cursor: inherit; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            z-index: 1; 
            transition: transform 0s !important; 
        }
        
        /* Wichtig: Wir steuern alles nur noch mit `left` und `transform: translateX` */
        .slider-button { left: 0; }
        /* Bei dir-left Schieberichtung muss der Button optisch nach rechts */
        .slider-container.dir-left .slider-button { 
            transform: translateX(calc(100% - 50px)); /* Schiebt ihn initial ganz nach rechts */
        }


        /* --- Modal CSS (wie gehabt) --- */
        .modal {
            display: none; position: fixed; z-index: 10; left: 0; top: 0;
            width: 100%; height: 100%; 
            background-color: rgba(0, 0, 0, 0.6); 
            justify-content: center; align-items: center;
        }
        .modal-content {
            background-color: var(--card-bg); 
            padding: 20px; border-radius: 20px; width: 80%; max-width: 400px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .close-button {
            color: var(--text-color); float: right; font-size: 28px; font-weight: bold; cursor: pointer;
        }
        .setting-option { margin-bottom: 15px; }
        .color-picker-container button {
            width: 30px; height: 30px; border-radius: 80%; border: 2px solid transparent; margin: 5px; cursor: pointer;
        }
        .color-picker-container button.active {
            border-color: white; box-shadow: 0 0 0 2px var(--card-bg);
        }
        #highscoreList { list-style-type: none; padding: 0; }
        #highscoreList li {
            padding: 10px; background-color: #2c2c2c; margin-bottom: 5px;
            border-radius: 20px; display: flex; justify-content: space-between;
        }
        .direction-buttons button, .precision-buttons button {
            padding: 10px 15px; margin: 5px 2px; border: 2px solid #555;
            background-color: #333; color: var(--text-color); border-radius: 20px;
            cursor: pointer; transition: background-color 0.3s;
        }
        .direction-buttons button.active, .precision-buttons button.active {
            background-color: var(--primary-color); border-color: var(--primary-color);
            color: var(--card-bg); font-weight: bold;
        }
    </style>
</head>
<body>

    <div class="game-container">
        <button id="helpButton" aria-label="Spielanleitung">?</button>
        <div class="icon-buttons">
            <button id="scoreButton" aria-label="Highscore anzeigen">üèÜ</button>
            <button id="settingsButton" aria-label="Einstellungen √∂ffnen">‚öôÔ∏è</button>
        </div>
        
        <h1>Stopp-Spiel</h1>
        <div id="display" class="precision-2">0.00s</div>
        
        <!-- NEUER WRAPPER F√úR BUTTON/SLIDER -->
        <div class="action-area-container">
            <button id="actionButton">Start</button>
            <div class="slider-container" id="sliderContainer">
                <div class="slider-button" id="sliderButton">‚Üí</div>
                <span class="slider-label" id="sliderLabel">Zum Neustart schieben</span>
            </div>
        </div>
        
        <p id="message"></p>
    </div>

    <!-- Modals (wie gehabt) -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeSettingsModal">&times;</span>
            <h2>Einstellungen</h2>
            <div class="setting-option">
                <label>Nachkommastellen:</label>
                <div class="precision-buttons">
                    <button data-precision="1">1</button>
                    <button data-precision="2" class="active">2</button>
                    <button data-precision="3">3</button>
                    <button data-precision="4">4</button>
                    <button data-precision="5">5</button>
                </div>
            </div>
            <div class="setting-option">
                <label>Akzentfarbe:</label>
                <div class="color-picker-container">
                    <button data-color="#00ff99" style="background-color: #00ff99;" class="active"></button>
                    <button data-color="#4da6ff" style="background-color: #4da6ff;"></button> <!-- Blau -->
                    <button data-color="#ff4d4d" style="background-color: #ff4d4d;"></button> <!-- Rot -->
                    <button data-color="#ffcc00" style="background-color: #ffcc00;"></button> <!-- Gelb -->
                </div>
            </div>
            <div class="setting-option">
                <label>Schieberichtung Neustart:</label>
                <div class="direction-buttons">
                    <button data-direction="right" class="active">Rechts ‚Üí</button>
                    <button data-direction="left">‚Üê Links</button>
                </div>
            </div>
        </div>
    </div>
    <div id="scoreModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeScoreModal">&times;</span>
            <h2>Highscores</h2>
            <ul id="highscoreList"></ul>
        </div>
    </div>
    <div id="helpModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeHelpModal">&times;</span>
            <h2>Spielanleitung</h2>
            <p><strong>Ziel:</strong> Stoppe den Timer so nah wie m√∂glich an einer ganzen Sekunde (z.B. 5.00s, 10.00s, etc.).</p>
            <p><strong>Punkte:</strong> Je genauer du bist, desto mehr Punkte gibt es.</p>
            <p><strong>Einstellungen:</strong> Du kannst die Anzahl der Nachkommastellen und die Farbe anpassen.</p>
        </div>
    </div>

    <script>
        // --- JavaScript-Code beginnt hier (Kombiniert und korrigiert) ---
        const display = document.getElementById('display');
        const actionButton = document.getElementById('actionButton');
        const sliderContainer = document.getElementById('sliderContainer');
        const sliderButton = document.getElementById('sliderButton');
        const sliderLabel = document.getElementById('sliderLabel');
        const messagePara = document.getElementById('message');
        const rootStyles = document.documentElement.style;
        const highscoreList = document.getElementById('highscoreList');
        const settingsModal = document.getElementById('settingsModal');
        const scoreModal = document.getElementById('scoreModal');
        const helpModal = document.getElementById('helpModal');
        const helpButton = document.getElementById('helpButton');
        const scoreButton = document.getElementById('scoreButton');
        const settingsButton = document.getElementById('settingsButton');
        const closeSettingsModal = document.getElementById('closeSettingsModal');
        const closeScoreModal = document.getElementById('closeScoreModal');
        const closeHelpModal = document.getElementById('closeHelpModal');

        let startTime;
        let animationFrameId;
        let isRunning = false;
        let settings = {
            precision: 2, 
            color: '#00ff99',
            direction: 'right'
        };
        let highscores = JSON.parse(localStorage.getItem('stoppspielHighscores')) || [];
        
        // --- Timer & Score Logik ---
        function toggleGame() {
            if (isRunning) { stopGame(); } else { startGame(); }
        }
        function startGame() {
            if (isRunning) return;
            isRunning = true;
            startTime = performance.now();
            actionButton.textContent = 'Stop';
            messagePara.textContent = '';
            hideRestartSlider(); 
            animationFrameId = requestAnimationFrame(updateDisplayLoop);
        }
        function stopGame() {
            if (!isRunning) return;
            isRunning = false;
            cancelAnimationFrame(animationFrameId);
            const elapsedTime = performance.now() - startTime;
            display.textContent = formatTime(elapsedTime, settings.precision);
            calculateScore(elapsedTime);
            showRestartSlider();
        }
        function updateDisplayLoop(timestamp) {
            const elapsedTime = timestamp - startTime;
            display.textContent = formatTime(elapsedTime, settings.precision);
            animationFrameId = requestAnimationFrame(updateDisplayLoop);
        }
        function formatTime(ms, precision) {
            const seconds = ms / 1000;
            return seconds.toFixed(precision) + 's';
        }
        function calculateScore(elapsedTime) {
            const seconds = elapsedTime / 1000;
            const decimalPart = seconds % 1; 
            const distanceFromTarget = Math.min(decimalPart, 1 - decimalPart);
            let score = 0;
            if (distanceFromTarget < 0.005) { score = 500; messagePara.textContent = "Perfekt! üéâ 500 Punkte!"; } 
            else if (distanceFromTarget < 0.01) { score = 200; messagePara.textContent = "Sehr gut! 200 Punkte!"; } 
            else if (distanceFromTarget < 0.05) { score = 50; messagePara.textContent = "Gut gemacht! 50 Punkte!"; } 
            else { score = 0; messagePara.textContent = "Versuch's nochmal!"; }
            if (score > 0) { saveHighscore(seconds.toFixed(settings.precision), score); }
        }
        function saveHighscore(time, score) {
            highscores.push({ time, score, date: new Date().toLocaleDateString() });
            highscores.sort((a, b) => b.score - a.score || parseFloat(a.time) - parseFloat(b.time));
            highscores = highscores.slice(0, 10); 
            localStorage.setItem('stoppspielHighscores', JSON.stringify(highscores));
        }
        function displayHighscores() {
            highscoreList.innerHTML = '';
            highscores.forEach((scoreItem, index) => {
                const li = document.createElement('li');
                li.innerHTML = `<span>#${index + 1} ${scoreItem.time}</span> <span>${scoreItem.score} Punkte</span>`;
                highscoreList.appendChild(li);
            });
        }

        // --- Einstellungs- und UI Logik ---

        function applySettings() {
            rootStyles.setProperty('--primary-color', settings.color);
            sliderContainer.classList.remove('dir-left', 'dir-right');
            sliderContainer.classList.add(`dir-${settings.direction}`);
            sliderButton.textContent = settings.direction === 'right' ? '‚Üí' : '‚Üê';
            sliderLabel.textContent = settings.direction === 'right' ? 'Zum Neustart schieben' : '‚Üê Zum Neustart schieben';

            display.classList.remove('precision-1', 'precision-2', 'precision-3', 'precision-4', 'precision-5');
            display.classList.add(`precision-${settings.precision}`);
            
            if (!isRunning) {
                const currentDisplayedTime = parseFloat(display.textContent); 
                display.textContent = formatTime(isNaN(currentDisplayedTime) ? 0 : currentDisplayedTime * 1000, settings.precision);
                // Wichtig: Setze den Slider-Button in die korrekte Startposition basierend auf der Richtung
                sliderButton.style.transform = ''; // CSS k√ºmmert sich um die initiale Position (links/rechts)
            }

            // Sicherstellen, dass die aktiven Buttons in den Modals korrekt angezeigt werden, nachdem Einstellungen angewendet wurden
            updateSettingsUI();
        }

        function updateSettingsUI() {
             document.querySelectorAll('.precision-buttons button').forEach(btn => {
                btn.classList.toggle('active', parseInt(btn.dataset.precision) === settings.precision);
            });
            document.querySelectorAll('.color-picker-container button').forEach(btn => {
                 btn.classList.toggle('active', btn.dataset.color === settings.color);
            });
            document.querySelectorAll('.direction-buttons button').forEach(btn => {
                 btn.classList.toggle('active', btn.dataset.direction === settings.direction);
            });
        }

        function showRestartSlider() {
            actionButton.classList.add('hidden');
            sliderContainer.classList.add('visible');
            // Beim Anzeigen des Sliders muss der Button auf 0 transform gesetzt werden, 
            // das CSS regelt die initiale left/right Position.
            sliderButton.style.transform = 'translateX(0px)';
        }

        function hideRestartSlider() {
            actionButton.classList.remove('hidden');
            sliderContainer.classList.remove('visible');
        }

        function resetGame() {
            isRunning = false;
            display.textContent = formatTime(0, settings.precision);
            actionButton.textContent = 'Start';
            hideRestartSlider();
            messagePara.textContent = '';
            // Setzt den Slider-Button auf die initiale Position zur√ºck, bereit f√ºr den n√§chsten Stop
            // Die applySettings() wird das transform: '' korrekt setzen, aber hier explizit f√ºr sofortigen Reset:
            sliderButton.style.transform = 'translateX(0px)'; 
        }

        // --- Universelle Slider/Drag-Logik f√ºr Touch und Maus (Optimiert) ---

        let isDragging = false;
        let initialClientX; 
        let initialButtonPos; /* Speichert die Startposition des Buttons beim Drag-Start */
        
        function getClientX(e) {
            return e.touches ? e.touches[0].clientX : e.clientX; /* Index 0 f√ºr den ersten Finger */
        }

        const startDragging = (e) => {
            if (!isRunning && sliderContainer.classList.contains('visible')) {
                isDragging = true;
                initialClientX = getClientX(e); 
                // Hol die aktuelle Transform-Position des Buttons beim Start
                const transform = window.getComputedStyle(sliderButton).transform;
                const matrix = new DOMMatrix(transform);
                initialButtonPos = matrix.m41; 

                sliderButton.style.transition = 'none'; 
                document.body.style.cursor = 'grabbing';
                e.preventDefault(); 
                
                document.addEventListener('mousemove', dragMove);
                document.addEventListener('mouseup', stopDragging);
                document.addEventListener('touchmove', dragMove);
                document.addEventListener('touchend', stopDragging);
            }
        };

        const stopDragging = (e) => {
            if (!isDragging) return;

            isDragging = false;
            sliderButton.style.transition = ''; 
            document.body.style.cursor = 'default';

            document.removeEventListener('mousemove', dragMove);
            document.removeEventListener('mouseup', stopDragging);
            document.removeEventListener('touchmove', dragMove);
            document.removeEventListener('touchend', stopDragging);
            
            const containerRect = sliderContainer.getBoundingClientRect();
            const buttonRect = sliderButton.getBoundingClientRect();
            const threshold = containerRect.width * 0.8;
            
            // Aktuelle Position nach dem Loslassen ermitteln
            const currentTransform = window.getComputedStyle(sliderButton).transform;
            const currentMatrix = new DOMMatrix(currentTransform);
            const currentPos = currentMatrix.m41; 

            // Pr√ºfen, ob der Schwellenwert erreicht wurde
            let successfullyDragged = false;
            if (settings.direction === 'right' && currentPos >= threshold) {
                successfullyDragged = true;
            } else if (settings.direction === 'left' && currentPos <= (containerRect.width - threshold - buttonRect.width)) {
                // Bei links ist die Logik komplexer, da wir von rechts nach links ziehen 
                // Aber mit der universalisierten dragMove Logik oben, sollte es einfacher sein
                // Wir pr√ºfen einfach ob currentPos nahe 0 ist (rechts am Container)
                if (currentPos < (containerRect.width * 0.2)) {
                     successfullyDragged = true;
                }
            }


            if (successfullyDragged) {
                 resetGame();
            }
            
            // Button zur√ºcksetzen, falls Schwellenwert nicht erreicht oder Reset nicht erfolgte
            sliderButton.style.transform = 'translateX(0px)';
            // Falls links, muss er wieder nach rechts (initiale Position im CSS)
            if (settings.direction === 'left') {
                 sliderButton.style.transform = 'translateX(calc(100% - 50px))';
            }
        };

        const dragMove = (e) => {
            if (!isDragging) return;

            e.preventDefault(); 

            const clientX = getClientX(e);
            const containerRect = sliderContainer.getBoundingClientRect();
            const buttonRect = sliderButton.getBoundingClientRect();
            const maxMove = containerRect.width - buttonRect.width;

            // Delta ist die Differenz zur initialen Maus/Fingerposition
            let deltaX = clientX - initialClientX;

            let newPos = initialButtonPos + deltaX;
            
            // Klemme die Position zwischen 0 und maxMove
            newPos = Math.max(0, Math.min(maxMove, newPos));
            sliderButton.style.transform = `translateX(${newPos}px)`;
        };


        // --- Event Listener Zuweisungen ---

        actionButton.addEventListener('click', toggleGame); 
        // Events an den Button binden, nicht an das Dokument f√ºr Start
        sliderButton.addEventListener('mousedown', startDragging);
        sliderButton.addEventListener('touchstart', startDragging);
        
        settingsButton.onclick = () => { settingsModal.style.display = 'flex'; updateSettingsUI(); };
        closeSettingsModal.onclick = () => { settingsModal.style.display = 'none'; };
        scoreButton.onclick = () => { displayHighscores(); scoreModal.style.display = 'flex'; };
        closeScoreModal.onclick = () => { scoreModal.style.display = 'none'; };
        helpButton.onclick = () => { helpModal.style.display = 'flex'; };
        closeHelpModal.onclick = () => { helpModal.style.display = 'none'; };

        window.addEventListener('click', (e) => {
            if (e.target == settingsModal || e.target == scoreModal || e.target == helpModal) {
                e.target.style.display = 'none';
            }
        });

        // Event Listener f√ºr Einstellungen (Delegation)
        document.querySelector('.precision-buttons').addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') { settings.precision = parseInt(e.target.dataset.precision); applySettings(); }
        });
        document.querySelector('.color-picker-container').addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') { settings.color = e.target.dataset.color; applySettings(); }
        });
         document.querySelector('.direction-buttons').addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') { settings.direction = e.target.dataset.direction; applySettings(); }
        });
        
        document.addEventListener('DOMContentLoaded', (event) => {
            applySettings(); 
        });

    </script>
</body>
</html>